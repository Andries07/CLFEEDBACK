<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Customer Feedback Kiosk</title>
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#000000">
<style>
  :root{
    --veil: rgba(255,255,255,.92);
    --accent:#f97316;
    --green:#16a34a; --green2:#22c55e; --yellow:#eab308; --orange:#f97316; --red:#dc2626;
  }
  html,body{margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .hero{min-height:100dvh;background:url('./background.jpg') center/cover no-repeat fixed;display:grid;place-items:center}
  .wrap{width:min(1100px,94vw);background:var(--veil);border-radius:20px;padding:clamp(14px,3vw,28px);box-shadow:0 12px 40px rgba(0,0,0,.25)}
  h1{margin:0 0 8px 0;font-weight:800}
  .subtitle{color:#444;margin-bottom:14px}
  .q{margin:12px 0 18px}
  .q-label{font-weight:700;margin-bottom:8px}
  .grid{display:grid;grid-template-columns:repeat(5,1fr);gap:12px}
  @media (max-width:1100px){.grid{grid-template-columns:repeat(3,1fr)}}
  @media (max-width:740px){.grid{grid-template-columns:repeat(2,1fr)}}

  .choice{display:flex;align-items:center;justify-content:center;gap:8px;padding:16px 12px;border:2px solid transparent;border-radius:14px;cursor:pointer;min-height:64px;text-align:center;font-weight:800}
  .choice input{display:none}
  .choice.active{outline:3px solid rgba(255,255,255,.85)}

  .card{background:#fff;border-radius:16px;padding:14px;box-shadow:0 8px 24px rgba(0,0,0,.12)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:720px){.row{grid-template-columns:1fr}}
  input[type=text],textarea{width:100%;padding:12px;border:1.6px solid #ddd;border-radius:12px;font-size:16px;background:#fff}
  textarea{min-height:90px;resize:vertical}
  .ck{display:flex;align-items:flex-start;gap:10px}.ck input{margin-top:4px}
  .actions{display:flex;gap:12px;margin-top:16px;align-items:center}
  .btn{background:var(--accent);color:#fff;border:0;border-radius:14px;padding:14px 18px;font-weight:800;font-size:18px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .muted{color:#666;font-size:14px}
  .thanks{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.66)}
  .thanks .inner{background:#fff;padding:24px;border-radius:18px;text-align:center;width:min(480px,92vw);box-shadow:0 16px 50px rgba(0,0,0,.4)}
  .footer{margin-top:8px;color:#444;font-size:14px;text-align:center}
  #netbadge{position:fixed;right:12px;bottom:12px;background:#0a7d24;color:#fff;padding:6px 10px;border-radius:999px;font:12px system-ui;opacity:.95;z-index:9999}
</style>
</head>
<body>
  <div class="hero">
    <div class="wrap">
      <h1>Quick Service Feedback</h1>
      <div class="subtitle">Please tap one answer per question.</div>

      <!-- QUESTIONS -->
      <div id="questions"></div>

      <!-- OPTIONAL DETAILS -->
      <div class="card" style="margin-top:16px">
        <h3>Optional details</h3>
        <div class="row">
          <input id="name" type="text" placeholder="Name (optional)">
          <input id="surname" type="text" placeholder="Surname (optional)">
        </div>
        <div class="row" style="margin-top:10px">
          <input id="phone" type="text" placeholder="Phone (optional)">
          <textarea id="feedback" placeholder="Additional feedback (optional)"></textarea>
        </div>
        <div class="ck" style="margin-top:10px">
          <input id="popia" type="checkbox">
          <label for="popia">I consent to the collection and processing of my personal information for customer service and quality feedback purposes, in accordance with the POPIA.</label>
        </div>
        <div class="muted" style="margin-top:6px">You don’t need to share personal details. If you do, ticking consent is required.</div>
      </div>

      <div class="actions">
        <button id="submitBtn" class="btn" disabled>Submit</button>
        <div class="muted" id="statusTxt"></div>
      </div>

      <div class="footer" id="footer"></div>
    </div>
  </div>

  <div class="thanks" id="thanks">
    <div class="inner">
      <h2>Thank you!</h2>
      <p>Your feedback has been recorded.</p>
      <button class="btn" id="againBtn">Done</button>
    </div>
  </div>

  <div id="netbadge">Online</div>

<script>
/* =================  CONFIG  ================= */
const CFG = {
  apiUrl: "https://script.google.com/macros/s/PASTE_YOUR_EXEC_ID/exec", // <-- PUT YOUR /exec URL HERE
  storeId: "CL-PRETORIA-001",
  deviceLabel: "Front Counter",
  deviceId: ""
};
</script>

<script>
/* ====== OFFLINE QUEUE (IndexedDB + LS) with one-time purge & local dedupe ====== */
const QUEUE_VERSION = 'v5';       // bump once to wipe any old stuck queue
const SENT_IDS_KEY  = 'cl_sent_ids_v1'; // local dedupe even if server isn’t updated yet
(function(){
  const verKey='cl_queue_version';
  if (localStorage.getItem(verKey) !== QUEUE_VERSION) {
    localStorage.removeItem('cl_feedback_pending_v4');
    localStorage.removeItem('cl_feedback_pending_v3');
    localStorage.removeItem('cl_feedback_pending_v2');
    localStorage.removeItem('cl_feedback_pending_v1');
    localStorage.setItem(verKey, QUEUE_VERSION);
  }
  if (!localStorage.getItem(SENT_IDS_KEY)) localStorage.setItem(SENT_IDS_KEY, JSON.stringify([]));
})();
function wasSent(clientId){
  try {
    const arr = JSON.parse(localStorage.getItem(SENT_IDS_KEY)||'[]');
    return arr.includes(clientId);
  } catch { return false; }
}
function markSent(clientId){
  try {
    const arr = JSON.parse(localStorage.getItem(SENT_IDS_KEY)||'[]');
    arr.push(clientId);
    // keep last 1000
    while (arr.length > 1000) arr.shift();
    localStorage.setItem(SENT_IDS_KEY, JSON.stringify(arr));
  } catch {}
}

const OfflineQueue = (function(){
  const DB_NAME='cl-feedback-db'; const STORE='pending'; const LS='cl_feedback_pending_v5';
  let dbp=null;
  function openDB(){
    if(!('indexedDB' in window)) return Promise.resolve(null);
    if(dbp) return dbp;
    dbp=new Promise((res)=>{ const req=indexedDB.open(DB_NAME,5);
      req.onupgradeneeded=()=>{ const db=req.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id',autoIncrement:true}); };
      req.onsuccess=()=>res(req.result); req.onerror=()=>res(null);
    }); return dbp;
  }
  async function add(item){
    item.clientId = item.clientId || (`${Date.now()}-${Math.random().toString(36).slice(2)}`);
    const db=await openDB();
    if(!db){
      const arr=JSON.parse(localStorage.getItem(LS)||'[]');
      const _tmpId=Date.now()+Math.random();
      arr.push({...item,_tmpId});
      localStorage.setItem(LS,JSON.stringify(arr));
      return {key:null,tmp:_tmpId};
    }
    return await new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readwrite');
      const st=tx.objectStore(STORE);
      const rq=st.add(item);
      rq.onsuccess=()=>res({key:rq.result,tmp:null});
      rq.onerror =()=>rej(rq.error);
    });
  }
  async function all(){
    const db=await openDB();
    if(!db) return JSON.parse(localStorage.getItem(LS)||'[]');
    return await new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readonly');
      const rq=tx.objectStore(STORE).getAll();
      rq.onsuccess=()=>res(rq.result||[]);
      rq.onerror   =()=>rej(rq.error);
    });
  }
  async function remove(key,tmp){
    const db=await openDB();
    if(!db){
      const arr=JSON.parse(localStorage.getItem(LS)||'[]');
      const next=arr.filter(x=>x._tmpId!==tmp);
      localStorage.setItem(LS,JSON.stringify(next));
      return;
    }
    await new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).delete(key);
      tx.oncomplete=()=>res();
      tx.onerror   =()=>rej(tx.error);
    });
  }
  async function clearAll(){
    const db=await openDB();
    if(!db){ localStorage.removeItem(LS); return; }
    await new Promise((res,rej)=>{
      const tx=db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).clear();
      tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);
    });
  }
  return { add, all, remove, clearAll };
})();

// One-time hard purge of any stuck queue (do this deployment once)
(async function hardPurgeOnce(){
  const key='cl_purged_once_v5';
  if (!localStorage.getItem(key)) {
    await OfflineQueue.clearAll();
    localStorage.setItem(key,'1');
  }
})();
</script>

<script>
/* ====== SENDER + FLUSH (treat duplicate:true as success) ====== */
function showToast(msg){
  const el=document.getElementById('statusTxt'); el.textContent=msg;
  clearTimeout(el._t); el._t=setTimeout(()=>el.textContent='',2500);
}
async function sendNow(q){
  // local client-side dedupe: if we already sent this id, skip and succeed
  if (q.body && q.body.clientId && wasSent(q.body.clientId)) return true;

  const r = await fetch(q.apiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
    body: JSON.stringify(q.body)
  });
  const txt = await r.text();
  // success if ok:true OR duplicate:true
  if (!r.ok || !/\"(ok|duplicate)\"\s*:\s*(true|\"true\")/.test(txt)) {
    throw new Error('Server '+r.status+' '+txt);
  }
  // mark sent locally
  if (q.body && q.body.clientId) markSent(q.body.clientId);
  return true;
}
async function flushQueue(){
  const items = await OfflineQueue.all();
  if (!items.length) return;
  for (const it of items){
    try {
      // if already marked sent locally, just drop it
      if (it.body && it.body.clientId && wasSent(it.body.clientId)) {
        await OfflineQueue.remove(it.id ?? null, it._tmpId ?? null);
        continue;
      }
      await sendNow(it);
      await OfflineQueue.remove(it.id ?? null, it._tmpId ?? null);
    } catch(e){
      break; // stop; keep remaining queued to retry later
    }
  }
}
</script>

<script>
/* ====== UI: colour buttons, required answers, POPIA ====== */
const QUESTIONS=[
  {id:'Q1',text:'Speed of service'},
  {id:'Q2',text:'Friendliness of staff'},
  {id:'Q3',text:'Order accuracy'},
  {id:'Q4',text:'Cleanliness of store'},
  {id:'Q5',text:'Overall experience'}
];
const CHOICES=[
  {text:'Excellent',score:5,color:'var(--green)',  fg:'#fff'},
  {text:'Good',     score:4,color:'var(--green2)', fg:'#fff'},
  {text:'Average',  score:3,color:'var(--yellow)', fg:'#111'},
  {text:'Poor',     score:2,color:'var(--orange)', fg:'#fff'},
  {text:'Bad',      score:1,color:'var(--red)',    fg:'#fff'}
];

function renderQuestions(){
  const qWrap=document.getElementById('questions');
  qWrap.innerHTML='';
  QUESTIONS.forEach(q=>{
    const el=document.createElement('div'); el.className='q';
    const grid = document.createElement('div');
    grid.className='grid';
    grid.dataset.qid = q.id;

    CHOICES.forEach(c=>{
      const lab = document.createElement('label');
      lab.className = 'choice';
      lab.dataset.score = String(c.score);
      // inline colour so old CSS cannot override
      lab.style.background = c.color;
      lab.style.color = c.fg;
      lab.innerHTML = `
        <input type="radio" name="${q.id}" value="${c.score}">
        <span class="label">${c.text}</span>
      `;
      grid.appendChild(lab);
    });

    const ql = document.createElement('div'); ql.className='q-label'; ql.textContent=q.text;
    el.appendChild(ql); el.appendChild(grid); qWrap.appendChild(el);
  });

  qWrap.querySelectorAll('.grid').forEach(grid=>{
    grid.addEventListener('click',e=>{
      const lab = e.target.closest('.choice'); if(!lab) return;
      grid.querySelectorAll('.choice').forEach(x=>x.classList.remove('active'));
      lab.classList.add('active');
      const inp=lab.querySelector('input'); if(inp) inp.checked=true;
      updateSubmitState();
    });
  });
}

function allAnswered(){
  return QUESTIONS.every(q => !!document.querySelector(`input[name="${q.id}"]:checked`));
}
function needsPOPIA(){
  return !!(document.getElementById('name').value.trim()||
            document.getElementById('surname').value.trim()||
            document.getElementById('phone').value.trim());
}
function updateSubmitState(){
  const ok = allAnswered() && (!needsPOPIA() || document.getElementById('popia').checked);
  document.getElementById('submitBtn').disabled = !ok;
}

async function onSubmit(){
  if(!allAnswered()){ showToast('Please answer all questions'); return; }
  if(needsPOPIA() && !document.getElementById('popia').checked){
    showToast('Please tick POPIA consent if you provide personal details'); return;
  }
  const answers = QUESTIONS.map(q=>{
    const score=Number(document.querySelector(`input[name="${q.id}"]:checked`).value);
    const choice=CHOICES.find(c=>c.score===score);
    return {questionId:q.id,choiceText:choice.text,choiceScore:score}; // NO emojis
  });
  const payload = {
    clientId: `${Date.now()}-${crypto.getRandomValues(new Uint32Array(1))[0].toString(16)}`,
    storeId: CFG.storeId, deviceLabel: CFG.deviceLabel, deviceId: CFG.deviceId || '',
    pressedAtUtc: new Date().toISOString(),
    answers,
    customer:{
      name:document.getElementById('name').value.trim(),
      surname:document.getElementById('surname').value.trim(),
      phone:document.getElementById('phone').value.trim(),
      feedback:document.getElementById('feedback').value.trim(),
      consent: document.getElementById('popia').checked || null
    }
  };

  // Queue then try to send
  const item = { apiUrl: CFG.apiUrl, body: payload, queuedAt: new Date().toISOString() };
  const ref = await OfflineQueue.add(item);
  try{
    await sendNow(item);
    await OfflineQueue.remove(ref.key ?? null, ref.tmp ?? null);
    document.getElementById('thanks').style.display='grid';
  }catch(e){
    showToast('Saved offline — will auto-sync ⏳');
    document.getElementById('thanks').style.display='grid';
  }

  // Reset UI
  setTimeout(()=>{
    document.querySelectorAll('input[type=radio]').forEach(i=>i.checked=false);
    document.querySelectorAll('.choice').forEach(x=>x.classList.remove('active'));
    ['name','surname','phone','feedback'].forEach(id=>document.getElementById(id).value='');
    document.getElementById('popia').checked=false;
    updateSubmitState();
  },50);
}

/* ====== INIT ====== */
function updateBadge(){
  const b=document.getElementById('netbadge');
  if (!b) return;
  if (navigator.onLine){ b.textContent='Online'; b.style.background='#0a7d24'; }
  else { b.textContent='Offline (queued)'; b.style.background='#a33'; }
}
function init(){
  // Optional: dynamic config that WON'T overwrite apiUrl is already handled above
  renderQuestions();
  updateSubmitState();
  document.addEventListener('input',e=>{ if(['name','surname','phone','feedback','popia'].includes(e.target.id)) updateSubmitState(); });
  document.getElementById('submitBtn').addEventListener('click', onSubmit);
  document.getElementById('againBtn').addEventListener('click',()=>{ document.getElementById('thanks').style.display='none'; });
  updateBadge();
  if (navigator.onLine) flushQueue();
  window.addEventListener('online', ()=>{ updateBadge(); flushQueue(); });
  window.addEventListener('offline', updateBadge);
  window.addEventListener('visibilitychange', ()=>{ if(!document.hidden && navigator.onLine) flushQueue(); });
  setInterval(()=>{ if(navigator.onLine) flushQueue(); }, 30000);
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
