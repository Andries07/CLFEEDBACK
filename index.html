<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Customer Feedback Kiosk</title>
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#000000" />
  <style>
    :root {
      --bg: #111;
      --veil: rgba(255,255,255,0.92);
      --accent: #f97316;
      --good: #16a34a;
      --warn: #eab308;
      --bad:  #dc2626;
      --card: #ffffff;
    }
    html, body { margin:0; padding:0; background:#000; color:#111; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .hero {
      min-height: 100dvh;
      background: url('./background.jpg') center/cover no-repeat fixed;
      display: grid; place-items: center;
    }
    .wrap {
      width: min(1100px, 94vw);
      background: var(--veil);
      border-radius: 20px;
      padding: clamp(14px, 3vw, 28px);
      box-shadow: 0 12px 40px rgba(0,0,0,.25);
      backdrop-filter: blur(2px);
    }
    h1 { margin: 0 0 8px 0; font-weight: 800; letter-spacing:.2px; }
    .subtitle { color:#444; margin-bottom: 14px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }
    @media (max-width: 1100px) { .grid { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 740px)  { .grid { grid-template-columns: repeat(2, 1fr); } }

    .q { margin: 12px 0 18px; }
    .q-label { font-weight: 700; margin-bottom: 8px; }
    .choice {
      display:flex; align-items:center; justify-content:center;
      gap:8px; padding:12px 10px; background:#fff; border:2px solid #ddd;
      border-radius: 14px; cursor: pointer; user-select:none; text-align:center;
      min-height:64px;
    }
    .choice input { display:none; }
    .choice[data-score="5"].active { border-color: var(--good); box-shadow: 0 0 0 3px rgba(22,163,74,.15) inset; }
    .choice[data-score="4"].active { border-color: #22c55e; }
    .choice[data-score="3"].active { border-color: var(--warn); box-shadow: 0 0 0 3px rgba(234,179,8,.15) inset; }
    .choice[data-score="2"].active,
    .choice[data-score="1"].active { border-color: var(--bad); box-shadow: 0 0 0 3px rgba(220,38,38,.12) inset; }
    .emoji { font-size: 26px; }
    .label { font-weight: 700; }

    .card {
      background: var(--card);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.12);
    }
    .card h3 { margin: 0 0 8px 0; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 720px) { .row { grid-template-columns: 1fr; } }
    input[type=text], textarea {
      width:100%; padding:12px 12px; border:1.6px solid #ddd; border-radius:12px; font-size:16px; background:#fff;
    }
    textarea { min-height: 90px; resize: vertical; }
    .ck { display: flex; align-items: flex-start; gap: 10px; }
    .ck input { margin-top: 4px; }

    .actions { display:flex; gap:12px; margin-top:16px; align-items:center; }
    .btn {
      background: var(--accent); color:#fff; border:0; border-radius:14px;
      padding: 14px 18px; font-weight:800; font-size: 18px; cursor:pointer;
    }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:#666; font-size: 14px; }

    .thanks {
      position: fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.66);
    }
    .thanks .inner {
      background:#fff; padding:24px; border-radius:18px; text-align:center; width:min(480px, 92vw);
      box-shadow:0 16px 50px rgba(0,0,0,.4);
    }
    .footer { margin-top: 8px; color:#444; font-size:14px; text-align:center; }

    /* Small online/offline pill */
    #netbadge { position:fixed; right:12px; bottom:12px; background:#0a7d24; color:#fff;
      padding:6px 10px; border-radius:999px; font:12px system-ui; opacity:.95; z-index:9999 }
  </style>
</head>
<body>
  <div class="hero">
    <div class="wrap">
      <h1>Quick Service Feedback</h1>
      <div class="subtitle">Please tap one answer per question.</div>

      <!-- QUESTIONS -->
      <div id="questions"></div>

      <!-- OPTIONAL DETAILS -->
      <div class="card" style="margin-top:16px;">
        <h3>Optional details</h3>
        <div class="row">
          <input id="name" type="text" placeholder="Name (optional)" />
          <input id="surname" type="text" placeholder="Surname (optional)" />
        </div>
        <div class="row" style="margin-top:10px;">
          <input id="phone" type="text" placeholder="Phone (optional)" />
          <textarea id="feedback" placeholder="Additional feedback (optional)"></textarea>
        </div>
        <div class="ck" style="margin-top:10px;">
          <input id="popia" type="checkbox" />
          <label for="popia">
            I consent to the collection and processing of my personal information for customer service and quality feedback purposes, in accordance with the POPIA.
          </label>
        </div>
        <div class="muted" style="margin-top:6px">
          You don’t need to share personal details. If you do, ticking consent is required.
        </div>
      </div>

      <!-- ACTIONS -->
      <div class="actions">
        <button id="submitBtn" class="btn" disabled>Submit</button>
        <div class="muted" id="statusTxt"></div>
      </div>

      <div class="footer" id="footer"></div>
    </div>
  </div>

  <!-- Thank you overlay -->
  <div class="thanks" id="thanks">
    <div class="inner">
      <h2>Thank you!</h2>
      <p>Your feedback has been recorded.</p>
      <button class="btn" id="againBtn">Done</button>
    </div>
  </div>

  <div id="netbadge">Online</div>

  <script>
  // ========= 1) SAFE DEFAULT CONFIG (put your /exec URL here!) =========
  const CFG = {
    apiUrl: "https://script.google.com/macros/s/AKfycbzQhYlYL49anIBFrSLLTDigkf_4cZ0hW3z2zANRMVJ3jcEnLBwN3G48PhhW-H9BMK6S_A/exec", // <-- CHANGE THIS
    storeId: "CL-PRETORIA-001",
    deviceLabel: "Front Counter",
    deviceId: ""
  };
  </script>

  <!-- ========= 2) Offline Queue (IndexedDB + localStorage) ========= -->
  <script>
  const OfflineQueue = (function(){
    const DB_NAME = 'cl-feedback-db';
    const STORE = 'pending';
    const LS_KEY = 'cl_feedback_pending_v1';
    let dbPromise = null;

    function openDB() {
      if (!('indexedDB' in window)) return Promise.resolve(null);
      if (dbPromise) return dbPromise;
      dbPromise = new Promise((resolve) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null); // fallback later
      });
      return dbPromise;
    }
    async function add(item) {
      const db = await openDB();
      if (!db) {
        const arr = JSON.parse(localStorage.getItem(LS_KEY) || '[]');
        if (item._tmpId == null) item._tmpId = Date.now() + Math.random();
        arr.push(item);
        localStorage.setItem(LS_KEY, JSON.stringify(arr));
        return;
      }
      await new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).add(item);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    async function getAll() {
      const db = await openDB();
      if (!db) return JSON.parse(localStorage.getItem(LS_KEY) || '[]');
      return await new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readonly');
        const req = tx.objectStore(STORE).getAll();
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
      });
    }
    async function clearAll() {
      const db = await openDB();
      if (!db) { localStorage.removeItem(LS_KEY); return; }
      await new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).clear();
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    return { add, getAll, clearAll };
  })();
  </script>

  <!-- ========= 3) Helper: sendNow + auto-flush ========= -->
  <script>
  function showToast(msg){
    const s = document.getElementById('statusTxt');
    s.textContent = msg;
    clearTimeout(s._t);
    s._t = setTimeout(() => s.textContent = '', 3000);
  }
  async function sendNow(q) {
    const r = await fetch(q.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(q.body)
    });
    const txt = await r.text();
    if (!r.ok || !/\"ok\"\s*:\s*true/.test(txt)) {
      throw new Error('Server error: ' + r.status + ' ' + txt);
    }
  }
  async function flushQueue() {
    const items = await OfflineQueue.getAll();
    if (!items.length) return;
    try {
      for (const it of items) await sendNow(it);
      await OfflineQueue.clearAll();
      showToast('Synced ' + items.length + ' pending ✅');
    } catch (e) {
      // keep items; will retry later
    }
  }
  function updateBadge(){
    const b = document.getElementById('netbadge');
    if (!b) return;
    if (navigator.onLine) { b.textContent='Online'; b.style.background='#0a7d24'; }
    else { b.textContent='Offline (queued)'; b.style.background='#a33'; }
  }
  window.addEventListener('online', () => { updateBadge(); flushQueue(); });
  window.addEventListener('offline', updateBadge);
  window.addEventListener('visibilitychange', () => { if (!document.hidden && navigator.onLine) flushQueue();});
  window.addEventListener('load', () => { updateBadge(); if (navigator.onLine) flushQueue(); });
  setInterval(() => { if (navigator.onLine) flushQueue(); }, 30000);
  </script>

  <!-- ========= 4) UI + Logic ========= -->
  <script>
  // Re-enable service worker + safe config loader (won't overwrite apiUrl)
  if (location.protocol.startsWith('http')) {
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
    (async () => {
      try {
        const r = await fetch('./config.json?_=' + Date.now());
        if (r.ok) {
          const cfg = await r.json();
          if (cfg.storeId)     CFG.storeId = cfg.storeId;
          if (cfg.deviceLabel) CFG.deviceLabel = cfg.deviceLabel;
          if (cfg.deviceId)    CFG.deviceId = cfg.deviceId;
          // Intentionally do NOT overwrite CFG.apiUrl here
        }
      } catch {}
      const f = document.getElementById('footer');
      if (f) f.textContent = (CFG.storeId || '') + ' • ' + (CFG.deviceLabel || '');
    })();
  }

  const QUESTIONS = [
    { id:'Q1', text:'Speed of service' },
    { id:'Q2', text:'Friendliness of staff' },
    { id:'Q3', text:'Order accuracy' },
    { id:'Q4', text:'Cleanliness of store' },
    { id:'Q5', text:'Overall experience' }
  ];
  const CHOICES = [
    { label:'😄 Excellent', score:5 },
    { label:'🙂 Good',      score:4 },
    { label:'😐 Average',   score:3 },
    { label:'🙁 Poor',      score:2 },
    { label:'😡 Bad',       score:1 }
  ];

  const qWrap = document.getElementById('questions');

  function renderQuestions() {
    qWrap.innerHTML = '';
    QUESTIONS.forEach(q => {
      const el = document.createElement('div');
      el.className = 'q';
      el.innerHTML = `
        <div class="q-label">${q.text}</div>
        <div class="grid" data-qid="${q.id}">
          ${CHOICES.map((c,i)=>`
            <label class="choice" data-score="${c.score}">
              <input type="radio" name="${q.id}" value="${c.score}">
              <span class="emoji">${c.label.split(' ')[0]}</span>
              <span class="label">${c.label.split(' ').slice(1).join(' ')}</span>
            </label>
          `).join('')}
        </div>
      `;
      qWrap.appendChild(el);
    });
    // activate selection styling
    qWrap.querySelectorAll('.grid').forEach(grid => {
      grid.addEventListener('click', (e) => {
        const lab = e.target.closest('.choice');
        if (!lab) return;
        grid.querySelectorAll('.choice').forEach(x => x.classList.remove('active'));
        lab.classList.add('active');
        const inp = lab.querySelector('input');
        if (inp) inp.checked = true;
        updateSubmitState();
      });
    });
  }

  function allAnswered() {
    return QUESTIONS.every(q => {
      const checked = qWrap.querySelector(`input[name="${q.id}"]:checked`);
      return !!checked;
    });
  }

  function needsPOPIA() {
    return !!(document.getElementById('name').value.trim() ||
              document.getElementById('surname').value.trim() ||
              document.getElementById('phone').value.trim());
  }

  function updateSubmitState() {
    const ok = allAnswered() && (!needsPOPIA() || document.getElementById('popia').checked);
    document.getElementById('submitBtn').disabled = !ok;
  }

  document.addEventListener('input', (e) => {
    if (['name','surname','phone','feedback','popia'].includes(e.target.id)) updateSubmitState();
  });

  renderQuestions();
  updateSubmitState();

  document.getElementById('submitBtn').addEventListener('click', async () => {
    if (!allAnswered()) { showToast('Please answer all questions'); return; }
    if (needsPOPIA() && !document.getElementById('popia').checked) {
      showToast('Please tick POPIA consent if you provide personal details'); return;
    }

    const answers = QUESTIONS.map(q => {
      const score = Number(qWrap.querySelector(`input[name="${q.id}"]:checked`).value);
      const choice = CHOICES.find(c => c.score === score);
      return { questionId: q.id, choiceLabel: choice.label, choiceScore: score };
    });

    const payload = {
      storeId: CFG.storeId,
      deviceLabel: CFG.deviceLabel,
      deviceId: CFG.deviceId || '',
      pressedAtUtc: new Date().toISOString(),
      answers,
      customer: {
        name: document.getElementById('name').value.trim(),
        surname: document.getElementById('surname').value.trim(),
        phone: document.getElementById('phone').value.trim(),
        feedback: document.getElementById('feedback').value.trim(),
        consent: document.getElementById('popia').checked || null
      }
    };

    // Queue first, then try to send now
    const queued = { apiUrl: CFG.apiUrl, body: payload, queuedAt: new Date().toISOString() };
    await OfflineQueue.add(queued);
    try {
      await sendNow(queued);
      await OfflineQueue.clearAll(); // this payload was sent; clear buffer just in case
      document.getElementById('thanks').style.display='grid';
    } catch (e) {
      showToast('Saved offline — will auto-sync ✅');
      document.getElementById('thanks').style.display='grid';
    }

    // Reset form for next user
    setTimeout(() => {
      document.querySelectorAll('input[type=radio]').forEach(i => i.checked=false);
      document.querySelectorAll('.choice').forEach(x => x.classList.remove('active'));
      ['name','surname','phone','feedback'].forEach(id => document.getElementById(id).value='');
      document.getElementById('popia').checked = false;
      updateSubmitState();
    }, 50);
  });

  document.getElementById('againBtn').addEventListener('click', () => {
    document.getElementById('thanks').style.display='none';
  });
  </script>
</body>
</html>
